# Elasticsearch术语

### 索引

> 索引（名词）：
>
> 如前所述，一个 *索引* 类似于传统关系数据库中的一个 *数据库* ，是一个存储关系型文档的地方。 *索引* (*index*) 的复数词为 *indices* 或 *indexes* 。
>
> 索引（动词）：
>
> *索引一个文档*  就是存储一个文档到一个 *索引* （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 `INSERT` 关键词，除了文档已存在时新文档会替换旧文档情况之外。
>
> 倒排索引：
>
> 关系型数据库通过增加一个 *索引* 比如一个 B树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 *倒排索引* 的结构来达到相同的目的。

## 分片

一个 *分片* 是一个底层的 *工作单元* ，它仅保存了全部数据中的一部分。

一个分片是一个 Lucene 的实例，以及它本身就是一个完整的搜索引擎。

分片分为**主分片**和**副本分片**，索引内任何一个文档都归属于一个主分片

## 索引和分片的比较

Elasticsearch中的一个索引是分片的集合， 而Elasticsearch中的分片是一个 Lucene 索引



## 近实时搜索

elasticsearch并不是实时搜索，而是近实时搜索，写入的文档需要在写入并打开一个新段才能被索引到，默认情况下每个分片会每秒自动刷新一次。

如果索引了一个文档却搜索不到，可以使用`refresh` API 手动刷新：

```
# 刷新所有的索引
POST /_refresh
# 只刷新 blogs 索引
POST /blogs/_refresh
```



## 段合并

由于在索引文档时创建的段逐渐增加会不断增加系统资源（句柄，IO，CPU等）的消耗，因此Elasticsearch在后台会自动将大小相近的段合并到一个更大的段。

段合并完成时：

- 新的段被刷新（flush）到磁盘。
- 写入一个包含新段且排除旧的和较小的段的新提交点
- 新的段被打开用来搜索
- 老的段被删除

### optimize API

可以看做 *强制合并API* ，它会将一个分片强制合并到`max_num_segments` 参数制定大小的段数目。这样做的意图是减少段的数量（通常减少到一个），来提升搜索性能。

**注意**：`optimize` API 不应该用在在一个动态索引（正在被活跃更新的索引），后台合并已经可以很好的完成工作。optimizing 会阻碍这个进程

optimizing 适合使用在日志等不会被经常更新的用例中：

```
POST /logstash-2014-10/_optimize?max_num_segments=1
```

