# 概念

>  由一组元素以一种特定的顺序组合或链接在一起，和数组很相似，然而在很多情况下链表比数组更有优势。特别是在执行 **插入** 和 **删除** 操作时链表由更高的效率。

链表需要动态地开辟存储空间，即运行时分配。



# 内容

## 单链表

>  各个元素之间通过一个指针彼此链接起来而组成。
>
> 链表开始处的元素称为头元素，末尾处的元素称为尾元素

### 成员

- 数据域
- 指针域（next指针）
  - 指向其后面的元素
  - 最后一个元素的指针域设置为`NULL`表示链表的尾端

### 遍历

从第一个元素开始，通过next指针直到找到所需要的元素为止。

### 接口

#### 初始化链表

```c
void list_init (List *list, void (*destroy)(void *data));
```

初始化由`list`指定的链表

此处 `destroy` 参数应为一个函数指针，提供一种释放动态分配的数据的方法。当链表被销毁时，destroy应该设置为free用来释放数据。对于包含了好几个动态成员的结构化数据，destroy应该设置为一个用户自定义的析构函数，通过对每一个动态分配的成员以及结构体自身调用free来释放数据。如果链表包含不应该释放的数据，destroy应该设置为`NULL`。

复杂度 O(1)

#### 销毁链表

```c
void list_destroy(List *list);
```

销毁由`list`指定的链表

如果传给`list_init`的参数`destroy`不为NULL，则移除链表的每个元素时都调用该函数（destroy指定的函数）一次

#### 插入下一个元素

```c
int list_ins_next(List *list, ListElmt *element, const void *data);
```

在`list`指定的链表`element`元素后面插入一个新元素。

插入成功返回0，否则返回-1

#### 移除下一个元素

```c
int list_rem_next(List *list, listElmt *element, void **data);
```

移除由list指定的链表中`element`后的那个元素，如果element设为`NULL`，则移除**链表头元素**。调用返回后，参数`data`指向已移除元素中存储的数据。

#### 计算链表长度

#### 获取链表头元素