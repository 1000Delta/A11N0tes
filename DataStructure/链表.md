# 概念

>  由一组元素以一种特定的顺序组合或链接在一起，和数组很相似，然而在很多情况下链表比数组更有优势。特别是在执行 **插入** 和 **删除** 操作时链表由更高的效率。

链表需要动态地开辟存储空间，即运行时分配。



# 内容

## 单链表

>  各个元素之间通过一个指针彼此链接起来而组成。
>
> 链表开始处的元素称为头元素，末尾处的元素称为尾元素

### 成员

- 数据域
- 指针域（next指针）
  - 指向其后面的元素
  - 最后一个元素的指针域设置为`NULL`表示链表的尾端

### 遍历

从第一个元素开始，通过next指针直到找到所需要的元素为止。

### 接口

#### 初始化链表

```c
void list_init (List *list, void (*destroy)(void *data));
```

初始化由`list`指定的链表

此处 `destroy` 参数应为一个函数指针，提供一种释放动态分配的数据的方法。当链表被销毁时，destroy应该设置为free用来释放数据。对于包含了好几个动态成员的结构化数据，destroy应该设置为一个用户自定义的析构函数，通过对每一个动态分配的成员以及结构体自身调用free来释放数据。如果链表包含不应该释放的数据，destroy应该设置为`NULL`。

复杂度 O(1)

#### 销毁链表

```c
void list_destroy(List *list);
```

销毁由`list`指定的链表

如果传给`list_init`的参数`destroy`不为NULL，则移除链表的每个元素时都调用该函数（destroy指定的函数）一次

#### 插入下一个元素

```c
int list_ins_next(List *list, ListElmt *element, const void *data);
```

在`list`指定的链表`element`元素后面插入一个新元素。

插入成功返回0，否则返回-1

#### 移除下一个元素

```c
int list_rem_next(List *list, ListElmt *element, void **data);
```

移除由list指定的链表中`element`后的那个元素，如果element设为`NULL`，则移除**链表头元素**。调用返回后，参数`data`指向已移除元素中存储的数据。

#### 计算链表长度（宏）

```c
int list_size(const List *list);
```

#### 获取链表头元素（宏）

```c
ListElmt *list_head(const List *list);
```

#### 获取链表尾元素（宏）

```c
ListElmt *list_tail(const List *list);
```

#### 判断是否为头元素（宏）

```c
int list_is_head(const ListElmt *element);
```

若是头元素则返回1，否则返回-1

#### 判断是否为尾元素（宏）

```c
int list_is_tail(const ListElmt *element);
```

返回值同上

#### 获取结点数据（宏）

```c
void list_data(const ListElmt *element);
```

#### 获取下一个结点（宏）

```c
ListElmt *list_next(const ListElmt *element);
```

### 实现与分析

#### 链表元素的构成

结构体`ListElmt`表示链表中的单个元素，具有数据域和指针域。

结构体`List`表示**链表这种数据结构**，由5个成员组成：

- `size` 表示链表中的元素个数；
- `match` 并不由链表本身使用，而是由从链表结构派生而来的新类型所使用；
- `destroy` 封装后传递给`list_init`（初始化）的**析构函数**
- `head` 指向链表中头结点元素的指针
- `tail` 指向链表中尾结点元素的指针

